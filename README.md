# 사물컴퓨팅 이론 및 실습

이클립스 기반의 C와 ARM-Cortex-M4 코어 ASTSAM4E16E MCU가 탑재되어 있는 ESTK보드를 이용하여 1학기 동안 만든 프로그램 설계 및 IoT 제품입니다.
아래는 운영체제를 다뤘던 내용과 중간 기말 프로젝트에 대한 내용이 담겨있습니다.

## 중간 프로젝트
### **주제명**  : 씨름로봇대회

**프로그램 설계**

ARM-Cortex-M4 코어 ASTSAM4E16E MCU가 탑재되어 있어 레고 센서 및 액츄에이터 제어 기능과 통신을 제어하는 ESTK 보드 판을 이용하여 일정 주파수 이상의 소리를 모바일 보드가 인식을 하면 90도로 회전하여 경기장에 진입하여 씨름 경기를 펼치는 씨름 로봇을 설계하였습니다.
씨름 로봇은 mindstorm사의 초음파센서와 소리센서, 컬러센서, 로봇자체를 만들기 위한 레고를 이용하여 설계하였는데, 기능은 ‘ubinos’ 라는 멀티 스레딩 지원 실시간 운영체제를 이용하여, 초음파 센서를 통해 상대편이 일정한 거리 이내로 접근하면 모터의 속도를 최대로 출력해내 상대방을 밀어내며, 씨름 로봇이 경기장 밖으로 탈출할 시 광센서를 통해 경기장 내로 다시 들어와 씨름하는 방식으로 이루어져 있습니다. 
 라즈베리파이나 아두이노는 오픈 소스를 활용하여 코드를 구현할 수 있지만, 씨름로봇은 직접 mindstorm사의 센서를 동작시키기 위해 소스 파일을 새롭게 만들어서 ESTK 보드 판에 인가시켜 로봇이 동작하게 구현하였습니다.
 
![P20191019_013629072_2C7269E8-FE46-4E59-A613-29296E5727F8](https://user-images.githubusercontent.com/45071833/102361391-845b1b00-3ff6-11eb-97e4-d5310e87d33d.jpg)

![P20191019_014118952_885A0072-8EF1-43D1-8D23-9B55E05A19AD](https://user-images.githubusercontent.com/45071833/102361397-86bd7500-3ff6-11eb-848f-d12066b18b63.jpg)

## 기말 프로젝트

### **주제명** : 맛있는 라면을 만들어 주는 로봇

**프로그램 설계** 

로봇을 구현하기 위해 제시된 방식은 암, 기본 크레인, 타워크레인 등이 있었고, 저희 조는 '중심이 튼튼한 로봇'에 초점을 맞춰 타워크레인 방식을 이용했습니다. 하지만 DC 모터는 최대 6개만 사용할 수 있었고, 몸체를 만들 레고 부품도 한정적이었습니다. 이로 인해 로봇이 메인지브에서 물건을 들어 올리는 모터의 무게를 버틸 수 없었습니다. 저희는 모터의 무게를 버틸만한 방법이 없을까 고심하다, 엘리베이터의 동작 원리를 떠올려 모터를 메인지브에 설치하는 대신 타워크레인 타이바 중간에 설치하고, 레일과 4개의 모터를 이용해 위아래로 움직이는 타워크레인을 고안했습니다. 

![KakaoTalk_20201216_233333852](https://user-images.githubusercontent.com/45071833/102362022-40b4e100-3ff7-11eb-995f-643acd29be61.jpg)

![KakaoTalk_20201216_233345939](https://user-images.githubusercontent.com/45071833/102362062-4a3e4900-3ff7-11eb-9058-377a49036bfc.jpg)

(설계과정)

## 과제 및 코딩

- 인터럽트

![IMG_4580](https://user-images.githubusercontent.com/45071833/102362601-ee27f480-3ff7-11eb-80af-b2f55d78f519.JPG)

(고찰)

인터럽트를 Cortex-M4 기반 ATSAM4E16E MCU의 타이머 카운터를 이용하여 직접 구현하는데 개념으로만 알고 있었던 인터럽트 사이의 괴리감이 있어서 처음에는 당황했었다. 이전에 중간고사에서 switch 인터럽트를 미리 사용해봐서 그런지 TC는 난해했지만, 그나마 switch 인터럽트의 사용방식은 어느정도 이해는 했던 것 같다. 
처음 코드를 구상할 때에는 sw2인터럽트에서 애초 lcd에 count 값이 0임을 아웃풋하려고 하였지만, 실패하였다. 그래서 바꾼 소스코드에서는 waiting이라는 함수를 이용하여, sw1과 sw2에서 lock과 unlock을 적절하게 이용해 count값을 조정할 수 있게 되었다. 다만 아쉬운 것은 timer인터럽트는 1초의 간격을 46800Hz마다 상승엣지에 인터럽트를 걸어서 도출해내기에, timer인터럽트를 조절할 수 있는 방법은 없었다. 만약에 timer인터럽트보다 우선순위가 높은 인터럽트가 있다면, count값을 더욱 정교하게 조정할 수 있었을 것이다. 또한, Cortex-M4 기반의 ATSAM4E16E의 인터럽트의 종류를 정확하게 안다면, 인터럽트의 우선순위를 정해서 count값을 정교하게 조정할 수 있을 것이다. 또한 인터럽트를 사용하는 개발자의 몫에 의해 프로그램의 성능이 크게 좌지우지될 것 같다. 만약 동일 우선순위의 인터럽트가 간격 차이가 거의 나지않게 들어오고, 그 중 먼저 들어온 인터럽트가 걸리는 시간이 길다면, 그 이후의 인터럽트는 동일 우선순위와 그 하위의 우선순위는 배제된다고 가정할 때, 현실상황에서 어떤 큰 일이 생길지 모르기 때문이다. 그래서 이 프로그램을 구현할 때, 인터럽트에서 수행되는 함수는 최대한 짧게, 무한루프 설정도 로컬함수에서 하게끔 설정해주었다. 단순히 인터럽트에서는 LOCK과 UNLOCK을 이용하여 간단하게 시작과 정지, 그리고 리셋을 실현시킬 수 있었다. 정교한 코드는 아니지만, 더 많은 인터럽트 종류를 알았다면, 더욱 정교하게 인터럽트를 주어 코드를 짤 수 있을 것이다.


