# 사물컴퓨팅 이론 및 실습

이클립스 기반의 C와 ARM-Cortex-M4 코어 ASTSAM4E16E MCU가 탑재되어 있는 ESTK보드를 이용하여 1학기 동안 만든 프로그램 설계 및 IoT 제품입니다.
아래는 운영체제를 다뤘던 내용과 중간 기말 프로젝트에 대한 내용이 담겨있습니다.

## 중간 프로젝트
### **주제명**  : 씨름로봇대회

**프로그램 설계**

ARM-Cortex-M4 코어 ASTSAM4E16E MCU가 탑재되어 있어 레고 센서 및 액츄에이터 제어 기능과 통신을 제어하는 ESTK 보드 판을 이용하여 일정 주파수 이상의 소리를 모바일 보드가 인식을 하면 90도로 회전하여 경기장에 진입하여 씨름 경기를 펼치는 씨름 로봇을 설계하였습니다.
씨름 로봇은 mindstorm사의 초음파센서와 소리센서, 컬러센서, 로봇자체를 만들기 위한 레고를 이용하여 설계하였는데, 기능은 ‘ubinos’ 라는 멀티 스레딩 지원 실시간 운영체제를 이용하여, 초음파 센서를 통해 상대편이 일정한 거리 이내로 접근하면 모터의 속도를 최대로 출력해내 상대방을 밀어내며, 씨름 로봇이 경기장 밖으로 탈출할 시 광센서를 통해 경기장 내로 다시 들어와 씨름하는 방식으로 이루어져 있습니다. 
 라즈베리파이나 아두이노는 오픈 소스를 활용하여 코드를 구현할 수 있지만, 씨름로봇은 직접 mindstorm사의 센서를 동작시키기 위해 소스 파일을 새롭게 만들어서 ESTK 보드 판에 인가시켜 로봇이 동작하게 구현하였습니다.
 
![P20191019_013629072_2C7269E8-FE46-4E59-A613-29296E5727F8](https://user-images.githubusercontent.com/45071833/102361391-845b1b00-3ff6-11eb-97e4-d5310e87d33d.jpg)

![P20191019_014118952_885A0072-8EF1-43D1-8D23-9B55E05A19AD](https://user-images.githubusercontent.com/45071833/102361397-86bd7500-3ff6-11eb-848f-d12066b18b63.jpg)

## 기말 프로젝트

### **주제명** : 맛있는 라면을 만들어 주는 로봇

**프로그램 설계** 

로봇을 구현하기 위해 제시된 방식은 암, 기본 크레인, 타워크레인 등이 있었고, 저희 조는 '중심이 튼튼한 로봇'에 초점을 맞춰 타워크레인 방식을 이용했습니다. 하지만 DC 모터는 최대 6개만 사용할 수 있었고, 몸체를 만들 레고 부품도 한정적이었습니다. 이로 인해 로봇이 메인지브에서 물건을 들어 올리는 모터의 무게를 버틸 수 없었습니다. 저희는 모터의 무게를 버틸만한 방법이 없을까 고심하다, 엘리베이터의 동작 원리를 떠올려 모터를 메인지브에 설치하는 대신 타워크레인 타이바 중간에 설치하고, 레일과 4개의 모터를 이용해 위아래로 움직이는 타워크레인을 고안했습니다. 

![KakaoTalk_20201216_233333852](https://user-images.githubusercontent.com/45071833/102362022-40b4e100-3ff7-11eb-995f-643acd29be61.jpg)

![KakaoTalk_20201216_233345939](https://user-images.githubusercontent.com/45071833/102362062-4a3e4900-3ff7-11eb-9058-377a49036bfc.jpg)

(설계과정)

## 과제 및 코딩

- 인터럽트

![IMG_4580](https://user-images.githubusercontent.com/45071833/102362601-ee27f480-3ff7-11eb-80af-b2f55d78f519.JPG)

(고찰)

인터럽트를 Cortex-M4 기반 ATSAM4E16E MCU의 타이머 카운터를 이용하여 직접 구현하는데 개념으로만 알고 있었던 인터럽트 사이의 괴리감이 있어서 처음에는 당황했었다. 이전에 중간고사에서 switch 인터럽트를 미리 사용해봐서 그런지 TC는 난해했지만, 그나마 switch 인터럽트의 사용방식은 어느정도 이해는 했던 것 같다. 
처음 코드를 구상할 때에는 sw2인터럽트에서 애초 lcd에 count 값이 0임을 아웃풋하려고 하였지만, 실패하였다. 그래서 바꾼 소스코드에서는 waiting이라는 함수를 이용하여, sw1과 sw2에서 lock과 unlock을 적절하게 이용해 count값을 조정할 수 있게 되었다. 다만 아쉬운 것은 timer인터럽트는 1초의 간격을 46800Hz마다 상승엣지에 인터럽트를 걸어서 도출해내기에, timer인터럽트를 조절할 수 있는 방법은 없었다. 만약에 timer인터럽트보다 우선순위가 높은 인터럽트가 있다면, count값을 더욱 정교하게 조정할 수 있었을 것이다. 또한, Cortex-M4 기반의 ATSAM4E16E의 인터럽트의 종류를 정확하게 안다면, 인터럽트의 우선순위를 정해서 count값을 정교하게 조정할 수 있을 것이다. 또한 인터럽트를 사용하는 개발자의 몫에 의해 프로그램의 성능이 크게 좌지우지될 것 같다. 만약 동일 우선순위의 인터럽트가 간격 차이가 거의 나지않게 들어오고, 그 중 먼저 들어온 인터럽트가 걸리는 시간이 길다면, 그 이후의 인터럽트는 동일 우선순위와 그 하위의 우선순위는 배제된다고 가정할 때, 현실상황에서 어떤 큰 일이 생길지 모르기 때문이다. 그래서 이 프로그램을 구현할 때, 인터럽트에서 수행되는 함수는 최대한 짧게, 무한루프 설정도 로컬함수에서 하게끔 설정해주었다. 단순히 인터럽트에서는 LOCK과 UNLOCK을 이용하여 간단하게 시작과 정지, 그리고 리셋을 실현시킬 수 있었다. 정교한 코드는 아니지만, 더 많은 인터럽트 종류를 알았다면, 더욱 정교하게 인터럽트를 주어 코드를 짤 수 있을 것이다.

- 모터 및 광센서 제어

![IMG_4318](https://user-images.githubusercontent.com/45071833/102362780-1fa0c000-3ff8-11eb-9136-1c38b573bc13.jpg)

(고찰)

이 실험에 앞서 미리 구현한 색상에 따라 모터의 속도가 달라지는 코드에서, 광센서를 이용하여 색상을 체크하는 task와 모터를 제어하는 task 둘 중에 어느 task를 우선순위를 더 높게 줄지는 먼저 실생활에 적용할 수 있는 것을 생각해 보았다. 예시로 신호등을 만났을 때를 가정하여, 녹색불이 들어왔을 때 모터의 속도를 900으로 만들고 노란색 불이 들어왔을 때 모터의 속도를 줄여 300으로 만들고 적색불이 들어왔을 때 모터의 속도를 0로 만드는 것을 구상하였다. 광센서에 인식되는 색상에 따라 모터의 속도를 바꿀 수 있기 때문에 신호등의green,yellow,red으로 나누어서 모터의 속도를 설정하였다. 신호등에 근접하여 신호등색이  red일때, 광센서에서 인식하는 빛을 red으로 두어 모터의 속도를 0으로 제한하였고,  신호등색이 yellow일때, 광센서에서 인식하는 빛을 yellow로 두고 모터의 속도를 300으로 두고, 신호등이 green일때에는 광센서에서 인식하는 빛을 blue로 두고 모터의 속도를 900으로 제한하였다. default값은 신호등이 없고 차가 없다는 것을 가정하고,표지판 속도의 최대가 1024라는 것을 가정으로 하여 모터의 속도를 1000으로 두고 실험을 진행하였다. 신호등 예시로는 task1인 광센서를 이용하여 색상을 체크하는 task가 task2인 모터를 제어하는 task보다 더 먼저 인식이 되어야 하기에 task1을 더 높은 우선순위로 지정하였다.
실험을 진행하는 도중에 광센서를 이용하여 색상을 체크하는 task를 task1으로 두고 모터를 제어하는 task를 task2라고 두었을 때, task1보다 task2가 우선적으로 수행되는 현상을 발견하게 되었다. 그 당시에는 연유를 몰랐지만, 소스코드를 짤 때, 미리 짜 둔 코드를 이용해서 사용했기 때문에, task1에 motor_init()를 한다든지 등의 단순한 실수를 했었다. 이 때에는 까닭을 찾지못해 bsp_busywaitms()함수를 이용하여 contextswitch을 못하게 남발하면서 사용했었다. 두번 째로, 심화학습으로 색상을 직접 calibration을 해서 모터의 속도를 조절하려는 실험을 하려고 했었다. 하지만 calibration설정을 다하지 않았음에도 불구하고 모터가 움직였다. 즉 taskfunc01에 먼저 cpu가 할당됐음에도 불구하고 곧 바로  context swtiching이 일어나 taskfunc02에 cpu가 할당되었다. bsp_busywaitms()함수를 이용하여 task간의 우선순위를 둬서 실험을 진행하려고 했지만, 시간을 동기화 시킨다는 것이 쉽지만은 않았다. 그래서 아직 직접 색상을 calbration을 통해 모터의 속도를 달라지게 하는 프로그램은 구현하지 못했다. 나중에 세마포어나 뮤텍스 등의 개념을 통해 크리티컬 섹션을 만들어서 task에 cpu가 할당될 때, 다른 task가 접근하지 못하도록 하는 것을 프로그램에 어떻게 적용되는지를 배워서 다시 한 번 시간이 남을 때 구현해보도록 할 것이다.




